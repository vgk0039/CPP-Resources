#include <iostream>

template <typename T, typename P>
decltype(auto) maximum(T a, P b)
{
   return (a > b) ? a : b;
}

int main()
{
   int x{7};
   double y{45.9};

   auto result = maximum(x, y);
   std::cout << "max : " << result << std::endl;
   std::cout << "sizeof(result) : " << sizeof(result) << std::endl;
   //---------Template Type Deduction And Explicit Arguments---------
   int a{10};
   int b{23};
   double c{34.7};
   double d{23.4};
   std::string e{"hello"};
   std::string f{"world"};

   // Explicit template arguments

   auto max = maximum<double>(a, f);
   std::cout << "max : " << max << std::endl;

   //---------Template Type Parameters By Reference--------
   /* #include <iostream>

 template <typename T> const T& maximum(const T& a, const T& b); // Declaration
 //template <typename T> T maximum(T a, T b); // Declaration

 int main(){

     double a {23.5};
     double b {51.2};

     std::cout << "Out - &a: " << &a << std::endl; // 0x111abc
     auto result = maximum(a,b);
     std::cout << "Out - &a: " << &a << std::endl; // 0x111abc

     return 0;
 }


 //Definition
 template <typename T> const T& maximum(const T& a, const T& b){
     std::cout << "In - &a: " << &a << std::endl; // // 0x111abc
     return (a > b ) ? a : b ;
 }
 */

   //------------Template Specialization------------

   /*
   #include <iostream>

      template <typename T> const T& maximum(const T& a, const T& b); // Declaration
     //template <typename T> T maximum(T a, T b); // Declaration

  int main(){

      double a {23.5};
      double b {51.2};

      std::cout << "Out - &a: " << &a << std::endl; // 0x111abc
      auto result = maximum(a,b);
      std::cout << "Out - &a: " << &a << std::endl; // 0x111abc

      return 0;
  }


  //Definition
  template <typename T> const T& maximum(const T& a, const T& b){
      std::cout << "In - &a: " << &a << std::endl; // // 0x111abc
      return (a > b ) ? a : b ;
  }

  /*
  template <typename T> T maximum(T a, T b){
      std::cout << "In - &a: " << &a << std::endl; // // 0x111abc
      return (a > b ) ? a : b ;
  }
  */

   return 0;
}
/*
---> Code templetes are used to avoid code repitation
---> Function templates are just blue prints . They are not real c++ code consumed by the compiler.The compiler
generates real c++ code by looking of the arguments you call your function template with.
---> The real c++ function generated by the compiler is called a template instance.
---> A template instance will be used when a similar function call (argument type is issued). No duplicates are generated by the compiler
---> cppinsights.io
---> Real function declaration and definitions ,aka template instances are created when you call the function with arguments
---> If the template parameters are of the same type (t,t), then the arguments you call the function with must also match , otherwise you get a compiler error
---> Template instances wont always do what you want . A good example is when you call our maximum function with pointers. Disaster .
---> There are tools like  cppinsights.io that can show us template installation . You can even use the debugger to infer that information from the activation record of template function
---> The arguments passed to a function template must support the operations that are done in the body of the function


*/